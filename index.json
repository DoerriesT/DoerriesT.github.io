[{"authors":null,"categories":null,"content":"Hi, my name is Tim. I am passionate about real-time graphics programming, and like to learn about and implement new real-time rendering techniques that further push the performance and realism of virtual scenes. My real-time rendering journey started with OpenGL 3.3 and OpenGL 4.5, but since then I have come to enjoy working closer to the hardware with modern APIs such as Vulkan and DirectX 12. In my previous role as Software Engineer at skilltree GmbH I was responsible for designing, implementing and maintaining a DirectX 12 renderer for an application for creating digital twins of cities based on map data. Currently I am employed at Epic Games as a Rendering Programmer.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Hi, my name is Tim. I am passionate about real-time graphics programming, and like to learn about and implement new real-time rendering techniques that further push the performance and realism of virtual scenes.","tags":null,"title":"Tim Dörries","type":"authors"},{"authors":["Tim Dörries"],"categories":[],"content":"Having learned a lot from the previous version of my engine, I started work on this new version in early 2021. Instead of diving straight into writing the renderer, I first did a lot of non-rendering work:\n I implemented a custom entity component system (ECS). The ECS is a so called archetype ECS, because it stores all entities with the same set of components (which define an archetype) in tightly packed arrays. This allows for very cache efficient and fast iteration over components. In order to facilitate multithreading, I implemented a fiber based job system, inspired by \u0026ldquo;Parallelizing the Naughty Dog Engine Using Fibers\u0026rdquo; as presented by Christian Gyrling. I also spent some time on an asset manager/system that does loading, caching, reference counting and unloading of assets. For physics I integrated PhysX, which is also used for character controllers in the engine. Skinned animation has been an item on my list for quite a while, so I took the time to finally implement this feature. While still far from animation systems in proper game engines, it does support setting up blend trees using a node graph system. The parameters for the blend trees are controlled through lua scripts.  Using the physics and character controller provided by PhysX and the animation system I had created, I implemented my first animated and controllable third person character! Since I had basic support for scripts at this point, I went a step further and added a ScriptComponent that can be used to attach arbitrary scripts to entities. Lua scripts can access the ECS, giving them access to most data in the engine.  In late 2021 I finally turned to implementing rendering features. Unlike the previous version, this renderer uses descriptor indexing for all resources, significantly simplifying descriptor set management. Vulkan and D3D12 are accessed through a custom abstraction layer, most of which was inherited from the previous iteration of the engine. Shaders are written once in HLSL and compiled with DXC to either DXIL (D3D12) or SPIR-V (Vulkan). Shader code for TAA, GTAO, Volumetric Fog, bloom and auto-exposure is also taken from the previous version.\n Synchronization and temporary resource allocation is managed by a simple render graph implementation. I also implemented relightable reflection probes. Each frame the g-buffer of a single probe is lit and then filtered with importance sampling. Very recently I implemented a first version of global illumination based on \u0026ldquo;Dynamic Diffuse Global Illumination (DDGI)\u0026rdquo; by Majercik et al.. Unfortunately I do not have access to any GPU capable of hardware supported raytracing, so for now the irradiance probes are generated in a dedicated baking step, where cubemaps are rendered for each probe. Once I get access to newer hardware, I plan to add support for updating the probes at runtime using raytracing. One neat property of irradiance volume techniques such as DDGI is that they can be sampled by Volumetric Fog, enabling very atmospheric scenes with volumetric lighting:  All the basic light types (directional/point/spot) present in the previous version are supported in the new version as well. Shadow maps for point and spot lights are automatically resized to match the resolution of the projected light size, minimizing wasted performance and memory due to undersampling. The system still stands to benefit from caching shadows, which is something I plan to implement in the future.  ","date":1643493600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1643493600,"objectID":"e25e25979ebc65e285391ff020735634","permalink":"https://doerriest.github.io/project/vengine2/","publishdate":"2022-01-30T00:00:00+02:00","relpermalink":"/project/vengine2/","section":"project","summary":"This is my current hobby render engine that I like to work on in my free time. (C++/D3D12/VK)","tags":[],"title":"VEngine 2 (Vulkan/D3D12 Hobby Render Engine)","type":"project"},{"authors":["Tim Dörries"],"categories":[],"content":"","date":1602021600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1602021600,"objectID":"4d265e8f7e787e656b6a92e1d7308705","permalink":"https://doerriest.github.io/publication/master/","publishdate":"2021-05-29T20:24:40+02:00","relpermalink":"/publication/master/","section":"publication","summary":"This masters thesis details the implementation of the popular Volumetric Fog technique for volumetric lighting and expands it with a unified solution for volumetric shadows for both volumes and billboards. Additionally, the checkerboard rendering technique is used reduce the cost of the effect. Written in C++ and Vulkan 1.2.","tags":[],"title":"Real-Time Volumetric Lighting with Volumetric Shadows","type":"publication"},{"authors":["Tim Dörries"],"categories":[],"content":"Wanting to familiarize myself with Vulkan, I wrote another hobby render engine from scratch. The learning curve was fairly steep, but eventually I came out on top. The first thing I implemented was a render graph/frame graph so that I would no longer have to manually synchronize access to GPU resources. The way it works is that one can register resources and passes using those resources in a reading or writing manner. The render graph then figures out the required synchronization (even supporting multiple queues aka async compute), creates temporary resources, records command buffers and submits them to the GPU.\nLater, I implemented an abstraction layer over both Vulkan and D3D12 so that the same rendering code and the same shaders could be used with both APIs. Creating this abstraction layer was very insightful to me and tought me a lot about D3D12.\nApart from these more interesting points, the renderer also features the following:\n Physically Based Rendering Dynamically updated parallax corrected cubemaps for reflections (Image Based Lighting). The cubemaps are rendered once into a g-buffer and then relit on demand. Temporal Anti-Aliasing. This one was a major step up in quality compared to FXAA/SMAA in my old hobby engine :) Shadowed point-, spot- and directional lights. Point- and spot lights share a shadow atlas. Bloom Particles And as part of my masters thesis: Volumetric Lighting with volumetric shadows for both volume and particle based participating media.  The \u0026lsquo;V\u0026rsquo; in \u0026lsquo;VEngine\u0026rsquo; stands for Vulkan. Naming things is one of the hardest problems in programming.\n","date":1602021600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1602021600,"objectID":"245129a2feb4f9e1aacd0f3df9ea8133","permalink":"https://doerriest.github.io/project/hobby-render-engine-vulkan/","publishdate":"2020-10-07T00:00:00+02:00","relpermalink":"/project/hobby-render-engine-vulkan/","section":"project","summary":"This was another hobby render engine that I also used to implement my masters thesis. (C++ and Vulkan/D3D12)","tags":[],"title":"VEngine (Vulkan/D3D12 Hobby Render Engine)","type":"project"},{"authors":["Tim Dörries"],"categories":[],"content":"This is a simple pathtracer written in CUDA and C++ featuring procedural shapes (sphere, cylinder, disk, cone paraboloid, quad and cube), different material types (lambertian diffuse, GGX specular), a BVH for accelerating ray-scene intersections, as well as support for simple textured scenes and HDRI environments. See https://github.com/DoerriesT/PathtracerCUDA for more details.\n","date":1598652000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1598652000,"objectID":"f11a1ebf9f087ebd5e4421a7baa1ae0f","permalink":"https://doerriest.github.io/project/cudapathtracer/","publishdate":"2020-08-29T00:00:00+02:00","relpermalink":"/project/cudapathtracer/","section":"project","summary":"A simple pathtracer written in C++ and CUDA.","tags":[],"title":"CUDA Pathtracer","type":"project"},{"authors":["Tim Dörries"],"categories":[],"content":"Inspired by the \u0026lsquo;Scalable Real-Time Global Illumination for Large Scenes\u0026rsquo; GDC talk held by Anton Yudintsev, I set out to implement a similar real-time global illumination solution.\nThe technique as described in the talk uses multiple cascades of irradiance volume probes around the camera to provide the indirect diffuse lighting. The probes store lighting information in the Half-Life 2 \u0026lsquo;ambient cube basis\u0026rsquo; and are updated every frame by casting rays into a low resolution voxelized representation of the scene (also in multiple cascades). The voxel representation of the scene is initially created with GPU-voxelization and then updated every frame by feeding the lit frame back into the voxel scene (screen space voxelization). This setup makes the technique fairly cheap, both in terms of processing and memory.\nHowever, when I implemented it in my hobby render engine (C++/Vulkan), the technique suffered from both light leaking artifacts common to many irradiance volume approaches and low lighting quality caused by the ambient cube basis used to store the irradiance. Searching for solutions to both problems, I found the Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields paper by Majercik et al., which uses a similar approach for GI. It differs in three key aspects from the first technique:\n  It uses hardware raytracing on the actual scene instead of raymarching in a voxelized representation of it.\n  Octahedron Mapping is used to store 8x8 texels of irradiance per probe, resulting in a higher resolution of irradiance information compared to the Half-Life 2 ambient cube basis.\n  And most importantly: Each probe stores the first two moments of depth in a 16x16 texel mini shadow map. This data is used similar in spirit to Variance Shadow Mapping to determine shading point to probe visiblity and combat light leaking.\n  Since I had no GPU capable of hardware raytracing and wanted to keep the good performance characteristics of my initial implementation, I kept the voxel representation of the scene. However, adapting the other two aspects drastically improved the visual quality and reduced light leaking. See the image below for what the irradiance data of the probes packed into a texture looks like:\nThe final problem I had to solve was that the depth information stored in each probe was generated by raymarching the low resolution voxel scene, leading to inaccuracies, which in turn caused the light leaking reduction to not be effective enough.\nI managed to partially solve this problem by increasing the resolution of the voxel scene. In order to stay in budget, I implemented a sparse voxel grid, where each grid cell has a pointer/index into a list of blocks of voxels. This way, only those cells that actually intersect geometry need to have memory for voxels allocated. Allocation, voxelization and freeing of voxel blocks is done entirely on the GPU without CPU intervention.\nWhile this approach enabled sufficiently high voxel resolutions, it is still slower than the original low resolution brute force way of storing and raymarching voxels. Depending on the scene, my final implementation of the effect also sometimes takes too long to converge to acceptable results (especially in low light conditions such as the lower sponza hallways). However, these experiments were still fairly educational to me and showed that the light leaking approach introduced by Majercik et al. can in theory solve most problematic light leaking cases (just not when you generate the depth information by tracing low resolution voxels).\nThe following image shows the indirect diffuse lighting term of the scene shown at the start of this post:\n","date":1582668000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582668000,"objectID":"51470536a69d2e33643886f75ee449a3","permalink":"https://doerriest.github.io/project/voxel-probe-gi/","publishdate":"2020-02-26T00:00:00+02:00","relpermalink":"/project/voxel-probe-gi/","section":"project","summary":"An experimental implementation (C++/Vulkan) of a real-time GI technique based on the 'Scalable Real-Time Global Illumination for Large Scenes' talk by Anton Yudintsev.","tags":[],"title":"Experiments with 'Scalable Real-Time Global Illumination'","type":"project"},{"authors":["Tim Dörries","Peter Berweiler"],"categories":[],"content":"This simple terrain editor is written in TypeScript and uses WebGL 2.0 for visualization. It features multiple different brushes for modifying the height map, painting additional diffuse/albedo maps, as well as placing trees (whose positions can be exported as a JSON file). The main feature is the erosion system (featuring a shallow water simulation for small rivers), which is an implementation of the technique proposed in \u0026ldquo;Fast Hydraulic Erosion Simulation and Visualization on GPU\u0026rdquo; by Mei et al. (2007). The project was created in collaboration with Peter Berweiler. Peter implemented most of the TypeScript related functionality and did most of the brushes. All the rendering aspects of the application were my responsibility. The erosion system was prototyped by Peter and later fully implemented by me.\nYou can try out a live demo at: https://peterberweiler.github.io/ITA-Project/\n","date":1579557600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1579557600,"objectID":"b76523e3c4c59e36b9cd9594d148d1b3","permalink":"https://doerriest.github.io/project/terrain-editor/","publishdate":"2020-01-21T00:00:00+02:00","relpermalink":"/project/terrain-editor/","section":"project","summary":"A simple terrain editor for creating height maps written in TypeScript and WebGL 2.0.","tags":[],"title":"Terrain Editor","type":"project"},{"authors":["Tim Dörries"],"categories":[],"content":"This is an implementation of the Separable Subsurface Scattering technique from http://www.iryoku.com/separable-sss/ in C++ and Vulkan 1.0. Additionally this demo features physically-based shading, image-based lighting, shadow mapping and temporal anti-aliasing. See https://github.com/DoerriesT/Separable-Subsurface-Scattering-Demo for more details.\n","date":1566770400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1566770400,"objectID":"419ab415322601a0c92edcaf0d9e3e34","permalink":"https://doerriest.github.io/project/subsurface-scattering/","publishdate":"2019-08-26T00:00:00+02:00","relpermalink":"/project/subsurface-scattering/","section":"project","summary":"Implementation of the Separable Subsurface Scattering technique from http://www.iryoku.com/separable-sss/ in C++ and Vulkan 1.0 ","tags":[],"title":"Separable Subsurface Scattering","type":"project"},{"authors":["Tim Dörries"],"categories":[],"content":"Using the \u0026lsquo;More than Fifty-Two\u0026rsquo; renderer code base (also written by me) as a starting point, I implemented my very first renderer/render engine that wasn\u0026rsquo;t tied to a specific project. It is written in C++, uses OpenGL 4.5 as its graphics API and features:\n Physically based rendering (PBR) Baked probe-based global illumination Parallax corrected cubemaps for specular reflections (image based lighting) Shadowed point-, spot- and directional lights Bloom Some not so realistic lens flare and camera dirt effects And as part of my bachelors thesis: several SSAO, depth of field and motion blur techniques  ","date":1542232800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1542232800,"objectID":"2092aa8177726e9da0c728863d1b1efc","permalink":"https://doerriest.github.io/project/hobby-render-engine-opengl/","publishdate":"2018-11-15T00:00:00+02:00","relpermalink":"/project/hobby-render-engine-opengl/","section":"project","summary":"This was my first hobby render engine that I also used to implement my bachelors thesis. (C++ and OpenGL 4.5)","tags":[],"title":"OpenGL Hobby Render Engine","type":"project"},{"authors":["Tim Dörries"],"categories":[],"content":"","date":1542232800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1542232800,"objectID":"9cc1eccf525744232b08e8ff6d3dd5ea","permalink":"https://doerriest.github.io/publication/bachelor/","publishdate":"2021-05-29T20:03:05+02:00","relpermalink":"/publication/bachelor/","section":"publication","summary":"For this bachelors thesis, different techniques for image-based post-processing effects (depth of field, motion blur and SSAO) were implemented, evaluated and compared against one another to give an overview of the field and guidance for choosing a suitable technique for a given effect. Written in C++ and OpenGL 4.5.","tags":[],"title":"State of the Art in Image-Based Post-Processing Effects","type":"publication"},{"authors":["Tim Dörries"],"categories":[],"content":"A proof of concept tool for painting textures in 3D. Uses Qt for the GUI and OpenGL for rendering the viewport. The tool allows to paint albedo, metallic, roughness, ambient occlusion, emissive and displacement maps. The painting works by writing out the UVs of the rendered model to a render target and reading back the values hovered by the mouse. These UV values are then used to draw line segments into the currently selected texture. The line segments are implemented as a series of splatted quads with an alpha falloff to simulate smooth lines.\n","date":1535580000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535580000,"objectID":"156ea33665c38c0993d06551e5f08208","permalink":"https://doerriest.github.io/project/meshpainter/","publishdate":"2018-08-30T00:00:00+02:00","relpermalink":"/project/meshpainter/","section":"project","summary":"A proof of concept tool for painting textures in 3D. Uses Qt for the GUI and OpenGL for rendering the viewport.","tags":[],"title":"Mesh Painter","type":"project"},{"authors":["Tim Dörries","Peter Berweiler","Max Ungar"],"categories":[],"content":"Having created our original \u0026lsquo;More than Fifty-Two\u0026rsquo; multiplayer card game sandbox in Java, we wanted to get some experience using C++ and improve upon our game by recreating it from scratch in C++.\nSimilar to the Java version, this new version of \u0026lsquo;More than Fifty-Two\u0026rsquo; is a multiplayer card game sandbox, giving players the power to create their own card game rule sets and card designs and share them online to play with others. Unlike the previous version, the game rules can now be edited in an in-game editor:\nVisually, the game received a big upgrade: It now has multiple environments in which to play cards. Taking inspiration from the solar panel table material present in the old Java version, one of the locations to play cards on is the solar panel of a satellite orbiting earth (see the image at the top of this post). As an excuse to experiment with ocean rendering (based on the classic FFT ocean rendering technique), there is an additional environment in the arctic ocean where players can play cards on a floating piece of ice:\nThis time around, I was again responsible for realizing the renderer and other engine functionality (except for networking).\n","date":1521928800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1521928800,"objectID":"23e0253b39494ce85f88248524e5772c","permalink":"https://doerriest.github.io/project/cardgame-cpp/","publishdate":"2018-03-25T00:00:00+02:00","relpermalink":"/project/cardgame-cpp/","section":"project","summary":"A C++ rework of the multiplayer card game sandbox which was originially developed with Java.","tags":[],"title":"'More than Fifty-Two' (C++)","type":"project"},{"authors":["Tim Dörries"],"categories":[],"content":"This is a demonstration of an effect for rendering fluids with implicit surfaces, written in C++ and OpenGL. It works by first simulating particles on the CPU:\nThen it renders a quad for each particle on the GPU:\nAnd finally it traces a ray in the quad\u0026rsquo;s pixel shader against the implicit surface formed by the distance field formed by the set of particles:\nEach particle on its own defines a spherical distance field where the implicit surface is defined as being at distance X from the surface. This results in small spheres that can look like droplets. By combining the distance fields of multiple particles, a more natural result can be achieved because the implicit surface now deforms according to the influences of multiple particles (see the image at the start of this post).\nSee https://github.com/DoerriesT/Implicit-Surface-Fluid-Rendering for more details.\n","date":1519682400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1519682400,"objectID":"e36a3549d81442b66f706f13e55d9989","permalink":"https://doerriest.github.io/project/portal-fluid/","publishdate":"2018-02-27T00:00:00+02:00","relpermalink":"/project/portal-fluid/","section":"project","summary":"Demonstration of a technique for rendering fluids similar to those found in the video game 'Portal 2'.","tags":[],"title":"Implicit Surface Fluid Rendering","type":"project"},{"authors":["Tim Dörries"],"categories":[],"content":"This is a small game for the PlayStation Vita that let\u0026rsquo;s you solve a Rubik\u0026rsquo;s Cube. It is written in C++ and uses libgxm as its graphics API. The cube can be rotated using the touchpad on the backside of the console. Individual cube slices can be rotated by touching and dragging them on the touchscreen on the front. As for the graphics, the game uses simple Blinn-Phong shading combined with an environment map, as well as tangent space normal mapping. The game also plays some royalty-free jazz music in the background.\n","date":1515708000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1515708000,"objectID":"46dd246c68ce2975410b86e57c4ea778","permalink":"https://doerriest.github.io/project/rubix-cube-psvita/","publishdate":"2018-01-12T00:00:00+02:00","relpermalink":"/project/rubix-cube-psvita/","section":"project","summary":"A small game that let's the player solve a Rubik's Cube on the PlayStation Vita.","tags":[],"title":"PlayStation Vita Rubik's Cube","type":"project"},{"authors":["Tim Dörries","Peter Berweiler","Max Ungar"],"categories":[],"content":"\u0026lsquo;More than Fifty-Two\u0026rsquo; is a multiplayer card game sandbox that two of my friends and me developed. It gives players the power to create their own card game rule sets and card designs and share them online to play with others. See the image below, showing what the game looks like in-game (Note that it even features an in-game chat):\nThe game is written in Java and uses LWJGL to access OpenGL as the graphics API used in its custom renderer. The renderer features shadow mapping, image based lighting and physically based rendering.\nThe game comes with a standalone editor application for creating the rules of new card games:\nAlthough my role during developement was mainly focused on implementing the rendering and \u0026ldquo;engine\u0026rdquo; aspects of the game, I was also responsible for creating the rule editor application.\n","date":1507932000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1507932000,"objectID":"d537e5d5124fef52752142972468565d","permalink":"https://doerriest.github.io/project/cardgame-java/","publishdate":"2017-10-14T00:00:00+02:00","relpermalink":"/project/cardgame-java/","section":"project","summary":"A multiplayer card game sandbox written in Java and using a custom OpenGL renderer.","tags":[],"title":"'More than Fifty-Two' (Java)","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://doerriest.github.io/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"}]